install.packages("ggstance")
rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
lininterp <- function(x, id, t) {
for (i in unique(id)) {
xi <- x[id==i]
ti <- t[id==i]
xi[is.na(xi)] <- approx(ti[!is.na(xi)], xi[!is.na(xi)], ti[is.na(xi)])$y
x[id==i] <- xi
}
return(x)
}
library(lfe)
library(stargazer)
library(knitr)
library(plm)
library(latex2exp)
library(ggplot2)
library(ggthemes)
library(estimatr)
library(gridExtra)
library(grid)
library(mvtnorm)
library(kableExtra)
library(data.table)
library(reshape2)
sgtype <- opts_knit$get("rmarkdown.pandoc.to")
sgstyle <- 'default'
colors <-  scale_color_solarized
colors_fill <- scale_fill_solarized
rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
rootdir <- "/Users/Hiro/Documents/GitHub/covid-impact"
source(paste(rootdir,"cases_and_policies/R/exploratory.R", sep="/"))
source(paste(rootdir,"cases_and_policies/R/dataprep.R",sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/varlabels.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/regprep.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/generatetables.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/bootstrap_felm.R", sep="/"))
rearrange <- function(x, id) {
for (i in unique(id)) {
xi <- x[id==i]
xi[!is.na(xi)] <- sort(xi[!is.na(xi)])
x[id==i] <- xi
}
return(x)
}
dropnotincreasing <- function(x, id, t) {
const <- (x <= panellag(x, id, t))
const[is.na(const)] <- FALSE
x[const & x>0] <- NA
return(x)
}
lininterp <- function(x, id, t) {
for (i in unique(id)) {
xi <- x[id==i]
ti <- t[id==i]
xi[is.na(xi)] <- approx(ti[!is.na(xi)], xi[!is.na(xi)], ti[is.na(xi)])$y
x[id==i] <- xi
}
return(x)
}
smoothtests <- function(x, id, t) {
x[is.na(x)] <- 0
return(lininterp(dropnotincreasing(rearrange(x,id),id,t),id,t))
}
df$neg.interp <- smoothtests(df$negative, df$state, df$date)
df$pos.interp <- df$cases #smoothtests(df$positive, df$state, df$date)
df$tot.interp <- df$neg.interp + df$pos.interp
L <- 7
df$tests <- paneldiff(df$tot.interp, df$state, df$date, lag=L)
df$testrate  <- df$tests/df$Population.2018*1000
df$testrate[df$testrate<0] <- NA
df$dlogtests <- paneldiff(log(sapply(df$testrate, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc <- df$ddeath/df$dcases*df$testrate
df$testratedc[df$dcases==0] <- 0
df$tests.ma <- paneldiff(panelma(df$neg.interp, df$state, df$date, 7) + df$cases,
df$state, df$date, lag=L)
df$testrate.ma  <- df$tests.ma/df$Population.2018*1000
df$testrate.ma[df$testrate.ma<0] <- NA
df$dlogtests.ma <- paneldiff(log(sapply(df$testrate.ma, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc.ma <- df$ddeath/df$dcases*df$testrate.ma
df$testratedc.ma[df$dcases==0] <- 0
L<-14
sprintf("lag(%s, %d)", bvars, L)
library(lfe)
library(stargazer)
library(knitr)
library(plm)
library(latex2exp)
library(ggplot2)
library(ggthemes)
library(estimatr)
library(gridExtra)
library(grid)
library(mvtnorm)
library(kableExtra)
library(data.table)
library(reshape2)
sgtype <- opts_knit$get("rmarkdown.pandoc.to")
sgstyle <- 'default'
colors <-  scale_color_solarized
colors_fill <- scale_fill_solarized
rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
rootdir <- "/Users/Hiro/Documents/GitHub/covid-impact"
source(paste(rootdir,"cases_and_policies/R/exploratory.R", sep="/"))
source(paste(rootdir,"cases_and_policies/R/dataprep.R",sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/varlabels.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/regprep.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/generatetables.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/bootstrap_felm.R", sep="/"))
rearrange <- function(x, id) {
for (i in unique(id)) {
xi <- x[id==i]
xi[!is.na(xi)] <- sort(xi[!is.na(xi)])
x[id==i] <- xi
}
return(x)
}
dropnotincreasing <- function(x, id, t) {
const <- (x <= panellag(x, id, t))
const[is.na(const)] <- FALSE
x[const & x>0] <- NA
return(x)
}
lininterp <- function(x, id, t) {
for (i in unique(id)) {
xi <- x[id==i]
ti <- t[id==i]
xi[is.na(xi)] <- approx(ti[!is.na(xi)], xi[!is.na(xi)], ti[is.na(xi)])$y
x[id==i] <- xi
}
return(x)
}
smoothtests <- function(x, id, t) {
x[is.na(x)] <- 0
return(lininterp(dropnotincreasing(rearrange(x,id),id,t),id,t))
}
df$neg.interp <- smoothtests(df$negative, df$state, df$date)
df$pos.interp <- df$cases #smoothtests(df$positive, df$state, df$date)
df$tot.interp <- df$neg.interp + df$pos.interp
L <- 7
df$tests <- paneldiff(df$tot.interp, df$state, df$date, lag=L)
df$testrate  <- df$tests/df$Population.2018*1000
df$testrate[df$testrate<0] <- NA
df$dlogtests <- paneldiff(log(sapply(df$testrate, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc <- df$ddeath/df$dcases*df$testrate
df$testratedc[df$dcases==0] <- 0
df$tests.ma <- paneldiff(panelma(df$neg.interp, df$state, df$date, 7) + df$cases,
df$state, df$date, lag=L)
df$testrate.ma  <- df$tests.ma/df$Population.2018*1000
df$testrate.ma[df$testrate.ma<0] <- NA
df$dlogtests.ma <- paneldiff(log(sapply(df$testrate.ma, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc.ma <- df$ddeath/df$dcases*df$testrate.ma
df$testratedc.ma[df$dcases==0] <- 0
DML2.for.PLM <- function(x, d, y, dreg, yreg, nfold=2) {
nobs <- nrow(x)
foldid <- rep.int(1:nfold,times = ceiling(nobs/nfold))[sample.int(nobs)]
I <- split(1:nobs, foldid)
ytil <- dtil <- rep(NA, nobs)
cat("fold: ")
#the following loop builds residuals over the folds
for(b in 1:length(I)){
dfit <- dreg(x[-I[[b]],], d[-I[[b]]]) #take a fold out
yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a folot out
dhat <- predict(dfit, x[I[[b]],], type="response") #predict the fold out
yhat <- predict(yfit, x[I[[b]],], type="response") #predict the fold out
dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual
ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial
cat(b," ")
}
rfit <- lm(ytil ~ dtil) #estimate the main parameter by regressing one residual on the other
coef.est <- coef(rfit)[2] #extract coefficient
se <- sqrt(vcovHC(rfit)[2,2]) #record standard error
cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
return( list(coef.est =coef.est , se=se, dtil=dtil, ytil=ytil) )
}
library(AER,hdm, randomForest)
install.packages("randomForest")
DML2.for.PLM <- function(x, d, y, dreg, yreg, nfold=2) {
nobs <- nrow(x)
foldid <- rep.int(1:nfold,times = ceiling(nobs/nfold))[sample.int(nobs)]
I <- split(1:nobs, foldid)
ytil <- dtil <- rep(NA, nobs)
cat("fold: ")
#the following loop builds residuals over the folds
for(b in 1:length(I)){
dfit <- dreg(x[-I[[b]],], d[-I[[b]]]) #take a fold out
yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a folot out
dhat <- predict(dfit, x[I[[b]],], type="response") #predict the fold out
yhat <- predict(yfit, x[I[[b]],], type="response") #predict the fold out
dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual
ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial
cat(b," ")
}
rfit <- lm(ytil ~ dtil) #estimate the main parameter by regressing one residual on the other
coef.est <- coef(rfit)[2] #extract coefficient
se <- sqrt(vcovHC(rfit)[2,2]) #record standard error
cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
return( list(coef.est =coef.est , se=se, dtil=dtil, ytil=ytil) )
}
library(AER,hdm, randomForest)
install.packages("randomForest")
library(lfe)
library(stargazer)
library(knitr)
library(plm)
library(latex2exp)
library(ggplot2)
library(ggthemes)
library(estimatr)
library(gridExtra)
library(grid)
library(mvtnorm)
library(kableExtra)
library(data.table)
library(reshape2)
sgtype <- opts_knit$get("rmarkdown.pandoc.to")
sgstyle <- 'default'
colors <-  scale_color_solarized
colors_fill <- scale_fill_solarized
rootdir <- system("git rev-parse --show-toplevel", intern=TRUE)[1]
rootdir <- "/Users/Hiro/Documents/GitHub/covid-impact"
source(paste(rootdir,"cases_and_policies/R/exploratory.R", sep="/"))
source(paste(rootdir,"cases_and_policies/R/dataprep.R",sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/varlabels.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/regprep.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/generatetables.R", sep="/"))
source(paste(rootdir,"cases_and_policies/rmd/bootstrap_felm.R", sep="/"))
rearrange <- function(x, id) {
for (i in unique(id)) {
xi <- x[id==i]
xi[!is.na(xi)] <- sort(xi[!is.na(xi)])
x[id==i] <- xi
}
return(x)
}
dropnotincreasing <- function(x, id, t) {
const <- (x <= panellag(x, id, t))
const[is.na(const)] <- FALSE
x[const & x>0] <- NA
return(x)
}
lininterp <- function(x, id, t) {
for (i in unique(id)) {
xi <- x[id==i]
ti <- t[id==i]
xi[is.na(xi)] <- approx(ti[!is.na(xi)], xi[!is.na(xi)], ti[is.na(xi)])$y
x[id==i] <- xi
}
return(x)
}
smoothtests <- function(x, id, t) {
x[is.na(x)] <- 0
return(lininterp(dropnotincreasing(rearrange(x,id),id,t),id,t))
}
df$neg.interp <- smoothtests(df$negative, df$state, df$date)
df$pos.interp <- df$cases #smoothtests(df$positive, df$state, df$date)
df$tot.interp <- df$neg.interp + df$pos.interp
L <- 7
df$tests <- paneldiff(df$tot.interp, df$state, df$date, lag=L)
df$testrate  <- df$tests/df$Population.2018*1000
df$testrate[df$testrate<0] <- NA
df$dlogtests <- paneldiff(log(sapply(df$testrate, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc <- df$ddeath/df$dcases*df$testrate
df$testratedc[df$dcases==0] <- 0
df$tests.ma <- paneldiff(panelma(df$neg.interp, df$state, df$date, 7) + df$cases,
df$state, df$date, lag=L)
df$testrate.ma  <- df$tests.ma/df$Population.2018*1000
df$testrate.ma[df$testrate.ma<0] <- NA
df$dlogtests.ma <- paneldiff(log(sapply(df$testrate.ma, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc.ma <- df$ddeath/df$dcases*df$testrate.ma
df$testratedc.ma[df$dcases==0] <- 0
DML2.for.PLM <- function(x, d, y, dreg, yreg, nfold=2) {
nobs <- nrow(x)
foldid <- rep.int(1:nfold,times = ceiling(nobs/nfold))[sample.int(nobs)]
I <- split(1:nobs, foldid)
ytil <- dtil <- rep(NA, nobs)
cat("fold: ")
#the following loop builds residuals over the folds
for(b in 1:length(I)){
dfit <- dreg(x[-I[[b]],], d[-I[[b]]]) #take a fold out
yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a folot out
dhat <- predict(dfit, x[I[[b]],], type="response") #predict the fold out
yhat <- predict(yfit, x[I[[b]],], type="response") #predict the fold out
dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual
ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial
cat(b," ")
}
rfit <- lm(ytil ~ dtil) #estimate the main parameter by regressing one residual on the other
coef.est <- coef(rfit)[2] #extract coefficient
se <- sqrt(vcovHC(rfit)[2,2]) #record standard error
cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
return( list(coef.est =coef.est , se=se, dtil=dtil, ytil=ytil) )
}
library(AER,hdm, randomForest)
