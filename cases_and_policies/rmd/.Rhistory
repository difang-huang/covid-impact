return(x)
}
dropnotincreasing <- function(x, id, t) {
const <- (x <= panellag(x, id, t))
const[is.na(const)] <- FALSE
x[const & x>0] <- NA
return(x)
}
lininterp <- function(x, id, t) {
for (i in unique(id)) {
xi <- x[id==i]
ti <- t[id==i]
xi[is.na(xi)] <- approx(ti[!is.na(xi)], xi[!is.na(xi)], ti[is.na(xi)])$y
x[id==i] <- xi
}
return(x)
}
smoothtests <- function(x, id, t) {
x[is.na(x)] <- 0
return(lininterp(dropnotincreasing(rearrange(x,id),id,t),id,t))
}
df$neg.interp <- smoothtests(df$negative, df$state, df$date)
df$pos.interp <- df$cases #smoothtests(df$positive, df$state, df$date)
df$tot.interp <- df$neg.interp + df$pos.interp
L <- 7
df$tests <- paneldiff(df$tot.interp, df$state, df$date, lag=L)
df$testrate  <- df$tests/df$Population.2018*1000
df$testrate[df$testrate<0] <- NA
df$dlogtests <- paneldiff(log(sapply(df$testrate, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc <- df$ddeath/df$dcases*df$testrate
df$testratedc[df$dcases==0] <- 0
df$tests.ma <- paneldiff(panelma(df$neg.interp, df$state, df$date, 7) + df$cases,
df$state, df$date, lag=L)
df$testrate.ma  <- df$tests.ma/df$Population.2018*1000
df$testrate.ma[df$testrate.ma<0] <- NA
df$dlogtests.ma <- paneldiff(log(sapply(df$testrate.ma, function(x)
max(x,exp(-1)))), df$state, df$date, lag=L)
df$testratedc.ma <- df$ddeath/df$dcases*df$testrate.ma
df$testratedc.ma[df$dcases==0] <- 0
df$logpop <- log(df$Population.2018)
df$logsq <- log(df$Square.Miles)
df$repub <- as.factor(df$party)
df$party_dum <- ifelse(df$party == "republican", 0, 1)
df$month3 <- ifelse(df$month==3,0,1)
df$month4 <- ifelse(df$month==4,0,1)
df$month5 <- ifelse(df$month==5,0,1)
df$month6 <- ifelse(df$month==6,0,1)
L <- L.c
pols <- c("pmaskbus","pk12","pshelter","pmovie","prestaurant","pnonessential")
infovars <- list(c("dlogdc", "logdc"),
c("dlogdc", "logdc","dlogdc.national", "logdc.national"))
infovarsd <- list(c("dlogdd", "logdd"),
c("dlogdd", "logdd","dlogdd.national", "logdd.national"))
vars <- c(infovars[[2]],infovarsd[[2]],pols,"pindex")
for(i in 1:length(vars)) {
L<-L.c
v <- sprintf("%s.L14",vars[i])
df[,v] <- panellag(df[,vars[i]],df$state,df$date, lag=L)
L<-L.d
v <- sprintf("%s.L21",vars[i])
df[,v] <- panellag(df[,vars[i]],df$state,df$date, lag=L)
}
for(i in 1:length(bvars)) {
L<-L.c
v <- sprintf("%s.L14",bvars[i])
df[,v] <- panellag(df[,bvars[i]],df$state,df$date, lag=L+14)
L<-L.d
v <- sprintf("%s.L21",bvars[i])
df[,v] <- panellag(df[,bvars[i]],df$state,df$date, lag=L+14)
}
df$test <- df$dlogtests
df$test[is.na(df$test)] <- 0
wvars <- c("logpop","logsq","Percent.Unemployed..2018.",
"Percent.living.under.the.federal.poverty.line..2018.",
"Percent.at.risk.for.serious.illness.due.to.COVID","party_dum",
"mask_percent", "logvote","test","month3","month4","month5","month6")
wvars.d <- c("logpop", "logsq","Percent.Unemployed..2018.",
"Percent.living.under.the.federal.poverty.line..2018.",
"Percent.at.risk.for.serious.illness.due.to.COVID","party_dum",
"mask_percent", "logvote","month3","month4","month5","month6")
bvars.c <- c("workplaces.L14","retail.L14","grocery.L14","transit.L14")
bvars.d <- c("workplaces.L21","retail.L21","grocery.L21","transit.L21")
xvars <- c(bvars.c,"dlogdc.L14","logdc.L14")
xvars.national <- c(bvars.c,"dlogdc.L14","logdc.L14","dlogdc.national.L14","logdc.national.L14")
xvars.d <- c(bvars.d,"dlogdd.L21","logdd.L21")
xvars.national.d <- c(bvars.d,"dlogdd.L21","logdd.L21","dlogdd.national.L21","logdd.national.L21")
pols.L14 <- c("pmaskbus.L14","pk12.L14","pshelter.L14","pmovie.L14","prestaurant.L14","pnonessential.L14")
pols.L21 <- c("pmaskbus.L21","pk12.L21","pshelter.L21","pmovie.L21","prestaurant.L21","pnonessential.L21")
AM<- function(y, x, w, reg,  steps=5){
# Initialize
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
i=1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i <- i+1 }
x <- lm((y-m1)~x)
w <- reg(as.vector(y-g1),w)
return(list(w = w , x = x))
}
DML2.for.PLM <- function(xv, wv, dv, yv, reg, sdf, nfold=5) {
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
for(b in 1:nfold){
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
yhat <- predict(yfit$x, x[I2,], type="response") + predict(yfit$w, w[I2,], type="response")
dhat <- predict(dfit$x, x[I2,], type="response") + predict(dfit$w, w[I2,], type="response")
dtil[I2] <- (d[I2] - dhat) #record residual
ytil[I2] <- (y[I2] - yhat) #record residual
cat(b," ")
}
sdf$ytil <- ytil
sdf$dtil <- dtil
rfit <- felm(ytil ~ dtil| 0| 0 | state, data=sdf) #estimate the main parameter by regressing one residual on the other
coef.est <- coef(rfit)[2] #extract coefficient
se <- sqrt(vcov(rfit)[2,2])
cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
return( list(coef.est = coef.est , se=se) )
}
# DML2.for.PLM <- function(x, d, y, dreg, yreg, sdf, nfold=5) {
#   unit <- as.double(sdf$state)
#   j <-  quantile(unit, c(1:(nfold-1))/nfold)
#   I <- vector(mode = "list", length = nfold)
#   I[[1]] <- unit <= j[1]
#   for (b in 2:(nfold-1)) {
#     I[[b]] <- (unit <= j[b])&(unit > j[b-1])
#   }
#   I[[nfold]] <- unit > j[nfold-1]
#   nobs <- nrow(x)
#   ytil <- dtil <- rep(NA, nobs)
#   for(b in 1:nfold){
#     I1 <- (I[[b]]==FALSE)
#     I2 <- I[[b]]
#     dfit <- dreg(x[I1,], d[I1]) # take a fold out
#     yfit <- yreg(x[I1,], y[I1]) # take a fold out
#     dhat <- predict(dfit, x[I2,], type="response") #predict the fold out
#     yhat <- predict(yfit, x[I2,], type="response") #predict the fold out
#     dtil[I2] <- (d[I2] - dhat) #record residual
#     ytil[I2] <- (y[I2] - yhat) #record residual
#     cat(b," ")
#   }
# sdf$ytil <- ytil
# sdf$dtil <- dtil
# rfit <- felm(ytil ~ dtil| 0| 0 | state, data=sdf) #estimate the main parameter by regressing one residual on the other
# coef.est <- coef(rfit)[2] #extract coefficient
# se <- sqrt(vcov(rfit)[2,2])
# cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
# return( list(coef.est = coef.est , se=se) )
# }
nfold <- 5
penalty = list(homoscedastic = FALSE, X.dependent.lambda =
FALSE, lambda.start = NULL, c = 1.7, gamma = 0.1)
reg.lasso <- function(x,y){ rlasso(x, y, penalty=penalty) } #ML method= rlasso
# dreg <- function(x,d){ cv.glmnet(x, d) } #ML method= rlasso
# yreg <- function(x,y){ cv.glmnet(x, y) } #ML method = rlasso
reg.RF <- function(x,y){ randomForest(x, y, maxnodes=8) } #ML method=Forest
j<-1
sdf <- subset(df, df$date>=as.Date(sprintf("2020-03-%s",7+L.c)))
# y = sdf$dlogdc
yv <- "dlogdc"
wv <- wvars
if (j==1){
dv <- "pmaskbus.L14"
p <- pols.L14[-1]
# d = sdf$pmaskbus.L14
} else if (j==2) {
dv <- "pk12.L14"
p <- pols.L14[-2]
# d = sdf$pk12.L14
} else if (j==3) {
dv <- "pshelter.L14"
p <- pols.L14[-3]
# d = sdf$pshelter.L14
} else if (j==4) {
dv <- "pindex.L14"
p <- c("pmaskbus.L14","pk12.L14")
# d = sdf$pindex.L14
}
# case growth without national
# x = as.matrix(cbind(sdf[,p],sdf[,xvars]))
xv <- c(xvars,p)
set.seed(1)
DML2.lasso <- DML2.for.PLM(xv, wv, dv, yv, reg.lasso, sdf, nfold = nfold)
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit
yft
yfit
yfit$x
AM<- function(y, x, w, reg,  steps=5){
# Initialize
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
i=1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(as.vector(y-g1),w)
return(list(fit.x=fitx , fit.w = fitw))
}
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
reg
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
reg<-reg.lasso
m1 <- predict(reg(as.vector(y- g1),w))
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i=1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i <- i+1 }
steps<-5
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i <- i+1 }
fitx <- lm((y-m1)~x)
list(fit.x=fitx , fit.w = fitw)
fitw <- reg(as.vector(y-g1),w)
list(fit.x=fitx , fit.w = fitw)
list(x=fitx , w = fitw)
g1
y-g1
w
fitw <- reg(as.vector(y-g1),w)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i <- i+1 }
g1
m1
g1
fitx <- lm((y-m1)~x)
fitx
fitw <- reg(as.vector(y-g1),w)
fitw
AM<- function(y, x, w, reg,  steps=5){
# Initialize
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
AM<- function(y, x, w, reg,  steps=5){
# Initialize
g1 <- predict(lm(y~x))
m1 <- predict(w,reg(as.vector(y- g1)))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
AM<- function(y, x, w, reg,  steps=5){
# Initialize
g1 <- predict(lm(y~x))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
yfit$x
yfit$w
predict(yfit$x, x[I2,], type="response")
predict(yfit$w, w[I2,], type="response")
yfit$x
predict(yfit$x, x[I2,])
predict(yfit$x, data.frame(x[I2,]))
DML2.for.PLM <- function(xv, wv, dv, yv, reg, sdf, nfold=5) {
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
for(b in 1:nfold){
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
yhat <- predict(yfit$x, data.frame(x[I2,])) + predict(yfit$w, w[I2,], type="response")
dhat <- predict(dfit$x, data.frame(x[I2,])) + predict(dfit$w, w[I2,], type="response")
dtil[I2] <- (d[I2] - dhat) #record residual
ytil[I2] <- (y[I2] - yhat) #record residual
cat(b," ")
}
sdf$ytil <- ytil
sdf$dtil <- dtil
rfit <- felm(ytil ~ dtil| 0| 0 | state, data=sdf) #estimate the main parameter by regressing one residual on the other
coef.est <- coef(rfit)[2] #extract coefficient
se <- sqrt(vcov(rfit)[2,2])
cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
return( list(coef.est = coef.est , se=se) )
}
predict(yfit$x, data.frame(x[I2,]), type="response")
predict(yfit$w, w[I2,], type="response")
length( predict(yfit$w, w[I2,], type="response"))
length(  predict(yfit$x, data.frame(x[I2,]), type="response"))
yfit.x
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
yfit$x
predict(yfit$x, data.frame(x[I2,]))
as.vector(predict(yfit$x, data.frame(x[I2,])))
x <- data.frame(x[I2,])
x
predict(yfit$x, x)
length( predict(yfit$x, x))
length(x)
x <- as.matrix(sdf[,xv])
x2 <- data.frame(x[I2,])
length(x2)
x <- as.matrix(sdf[,xv])
length(x)
length(x[I2,])
sizeof(x[I2,])
nrows(x[I2,])
nrow(x[I2,])
nrow(w[I2,])
x2 <- as.matrix(x[I2,])
predict(yfit$x, x2)
predict(lm(y~sdf[,xv]))
paste(yv, "~", xv, sep=" ")
paste(yv, "~",  paste(xv, collapse=" + "), sep=" ")
AM<- function(yv, xv, w, df, reg,  steps=5){
y <- df[,yv]
df[,"y"] <- y
# Initialize
fmla <- as.formula(paste("y", "~",  paste(xv, collapse=" + "), sep=" "))
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
df[,"y"] <- y-m1
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm(fmla, data=df)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
yfit <- AM(yv, xv, wv, sdf[I1,], reg)
y <- sdf[,yv]
w <- sdf[,wv]
sdf[,"y"] <- y
# Initialize
fmla <- as.formula(paste("y", "~",  paste(xv, collapse=" + "), sep=" "))
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
df[,"y"] <- y-m1
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
while(i<= steps) {
df$y <- y-m1
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
y-m1
length( y-m1)
length( sdf$y)
while(i<= steps) {
sdf$y <- y-m1
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm(fmla, data=sdf)
fitw <- reg(w,as.vector(y-g1))
AM<- function(yv, xv, wv, sdf, reg,  steps=5){
y <- sdf[,yv]
w <- sdf[,wv]
sdf[,"y"] <- y
# Initialize
fmla <- as.formula(paste("y", "~",  paste(xv, collapse=" + "), sep=" "))
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
sdf$y <- y-m1
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm(fmla, data=sdf)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(yv, xv, wv, sdf[I1,], reg)
dfit <- AM(dv, xv, wv, sdf[I1,], reg)
x2 <-  sdf[I2,xv]
yhat <- predict(yfit$x,data=sdf[I2,]) + predict(yfit$w, w[I2,], type="response")
predict(yfit$x,newdata=sdf[I2,])
yhat <- predict(yfit$x,newdata=sdf[I2,]) + predict(yfit$w, w[I2,], type="response")
dhat <- predict(dfit$x,newdata=sdf[I2,])+ predict(dfit$w, w[I2,], type="response")
dtil[I2] <- (d[I2] - dhat) #record residual
ytil[I2] <- (y[I2] - yhat) #record residual
