list(fit.x=fitx , fit.w = fitw)
fitw <- reg(as.vector(y-g1),w)
list(fit.x=fitx , fit.w = fitw)
list(x=fitx , w = fitw)
g1
y-g1
w
fitw <- reg(as.vector(y-g1),w)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(as.vector(y-g1),w))
i <- i+1 }
g1
m1
g1
fitx <- lm((y-m1)~x)
fitx
fitw <- reg(as.vector(y-g1),w)
fitw
AM<- function(y, x, w, reg,  steps=5){
g1 <- predict(lm(y~x))
m1 <- predict(reg(as.vector(y- g1),w))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
AM<- function(y, x, w, reg,  steps=5){
g1 <- predict(lm(y~x))
m1 <- predict(w,reg(as.vector(y- g1)))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
AM<- function(y, x, w, reg,  steps=5){
g1 <- predict(lm(y~x))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
g1 <- predict(lm((y-m1)~x))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm((y-m1)~x)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
yfit$x
yfit$w
predict(yfit$x, x[I2,], type="response")
predict(yfit$w, w[I2,], type="response")
yfit$x
predict(yfit$x, x[I2,])
predict(yfit$x, data.frame(x[I2,]))
DML2.for.PLM <- function(xv, wv, dv, yv, reg, sdf, nfold=5) {
unit <- as.double(sdf$state)
j <-  quantile(unit, c(1:(nfold-1))/nfold)
I <- vector(mode = "list", length = nfold)
I[[1]] <- unit <= j[1]
for (b in 2:(nfold-1)) {
I[[b]] <- (unit <= j[b])&(unit > j[b-1])
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
for(b in 1:nfold){
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
dfit <- AM(d[I1], x[I1,], w[I1,], reg)
yhat <- predict(yfit$x, data.frame(x[I2,])) + predict(yfit$w, w[I2,], type="response")
dhat <- predict(dfit$x, data.frame(x[I2,])) + predict(dfit$w, w[I2,], type="response")
dtil[I2] <- (d[I2] - dhat) #record residual
ytil[I2] <- (y[I2] - yhat) #record residual
cat(b," ")
}
sdf$ytil <- ytil
sdf$dtil <- dtil
rfit <- felm(ytil ~ dtil| 0| 0 | state, data=sdf) #estimate the main parameter by regressing one residual on the other
coef.est <- coef(rfit)[2] #extract coefficient
se <- sqrt(vcov(rfit)[2,2])
cat(sprintf("\ncoef (se) = %g (%g)\n", coef.est , se))
return( list(coef.est = coef.est , se=se) )
}
predict(yfit$x, data.frame(x[I2,]), type="response")
predict(yfit$w, w[I2,], type="response")
length( predict(yfit$w, w[I2,], type="response"))
length(  predict(yfit$x, data.frame(x[I2,]), type="response"))
yfit.x
yfit <- AM(y[I1], x[I1,], w[I1,], reg)
yfit$x
predict(yfit$x, data.frame(x[I2,]))
as.vector(predict(yfit$x, data.frame(x[I2,])))
x <- data.frame(x[I2,])
x
predict(yfit$x, x)
length( predict(yfit$x, x))
length(x)
x <- as.matrix(sdf[,xv])
x2 <- data.frame(x[I2,])
length(x2)
x <- as.matrix(sdf[,xv])
length(x)
length(x[I2,])
sizeof(x[I2,])
nrows(x[I2,])
nrow(x[I2,])
nrow(w[I2,])
x2 <- as.matrix(x[I2,])
predict(yfit$x, x2)
predict(lm(y~sdf[,xv]))
paste(yv, "~", xv, sep=" ")
paste(yv, "~",  paste(xv, collapse=" + "), sep=" ")
AM<- function(yv, xv, w, df, reg,  steps=5){
y <- df[,yv]
df[,"y"] <- y
fmla <- as.formula(paste("y", "~",  paste(xv, collapse=" + "), sep=" "))
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
df[,"y"] <- y-m1
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm(fmla, data=df)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
yfit <- AM(yv, xv, wv, sdf[I1,], reg)
y <- sdf[,yv]
w <- sdf[,wv]
sdf[,"y"] <- y
fmla <- as.formula(paste("y", "~",  paste(xv, collapse=" + "), sep=" "))
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
df[,"y"] <- y-m1
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
while(i<= steps) {
df$y <- y-m1
g1 <- predict(lm(fmla, data=df))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
y-m1
length( y-m1)
length( sdf$y)
while(i<= steps) {
sdf$y <- y-m1
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm(fmla, data=sdf)
fitw <- reg(w,as.vector(y-g1))
AM<- function(yv, xv, wv, sdf, reg,  steps=5){
y <- sdf[,yv]
w <- sdf[,wv]
sdf[,"y"] <- y
fmla <- as.formula(paste("y", "~",  paste(xv, collapse=" + "), sep=" "))
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y- g1)))
i<-1
while(i<= steps) {
sdf$y <- y-m1
g1 <- predict(lm(fmla, data=sdf))
m1 <- predict(reg(w,as.vector(y-g1)))
i <- i+1 }
fitx <- lm(fmla, data=sdf)
fitw <- reg(w,as.vector(y-g1))
return(list(x=fitx , w = fitw))
}
I[[nfold]] <- unit > j[nfold-1]
nobs <- nrow(sdf)
ytil <- dtil <- rep(NA, nobs)
w <- as.matrix(sdf[,wv])
x <- as.matrix(sdf[,xv])
d <- as.vector(sdf[,dv])
y <- as.vector(sdf[,yv])
b<-1
I1 <- (I[[b]]==FALSE)
I2 <- I[[b]]
yfit <- AM(yv, xv, wv, sdf[I1,], reg)
dfit <- AM(dv, xv, wv, sdf[I1,], reg)
x2 <-  sdf[I2,xv]
yhat <- predict(yfit$x,data=sdf[I2,]) + predict(yfit$w, w[I2,], type="response")
predict(yfit$x,newdata=sdf[I2,])
yhat <- predict(yfit$x,newdata=sdf[I2,]) + predict(yfit$w, w[I2,], type="response")
dhat <- predict(dfit$x,newdata=sdf[I2,])+ predict(dfit$w, w[I2,], type="response")
dtil[I2] <- (d[I2] - dhat) #record residual
ytil[I2] <- (y[I2] - yhat) #record residual
library(rmarkdown)
render_site("regressionsWithPlots.Rmd")
install.packages("dotwhisker")
if (!require("remotes")) install.packages("remotes"); remotes::install <- github("fsolt/dotwhisker")
library(remotes)
if (!require("remotes")) install.packages("remotes"); remotes::install <- github("fsolt/dotwhisker")
remotes::install_github("fsolt/dotwhisker")
install.packages("ggplot2")
local({r <- getOption("repos")
       r["CRAN"] <- "https://mirror.rcg.sfu.ca/mirror/CRAN/"
       options(repos=r)
       options(Ncpus=30L)
})
install.packages("ggplot2")
getOption("repos")
capabilities("libcurl")
chooseCRANmirror()
q()
n
library(rmarkdown)
render_site("cf-pindex.Rmd")
render_site("counterfactuals.Rmd")
render_site("cf-pindex.Rmd")
summary(df$pindex)
summary(as.vector(df$pindex))
summary(as.vector(df$pshelter))
summary(as.factor(as.vector(df$pshelter)))
summary(as.factor(as.vector(df$pindex)))
piy
summary(piy)
di
L.c <- 14
use.national <- FALSE
piy
pols
statevars
bvars
infovars
tvars
xlist
ilist
summary(piy)
summary(piy)
?felm
q()
n
library(rmarkdown)
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd"); render_site("counterfactuals.Rmd")
q()
n
library(rmarkdown)
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd")
?arima
?arima.sim
arima.sim
?filter
?filter
filter
ls
ls()
df
min(df$date)
min(sdf$date)
which(df$date==min(sdf$date))
t0 <- which(df$date==min(sdf$date))
df[t0,]
?arima
?arima.sim
?filter
simmodel("Washington")
options(error=recover)
simmodel("Washington")
n
ls()
check
lagy0
dY0
Y0
it0
check
lagy0
difflag
length(Y0)
Y0
lagy0
c
simmodel("Washington")
simmodel("Washington", samplecoefs = TRUE)
check
Y0
c
m
simmodel("Washington", samplecoefs = TRUE)
e
ls()
simmodel("Washington", samplecoefs = TRUE)
ls()
e
x
dim(x)
dim(e)
x' + e'
t(x) + e
vector(x)
as.vector(x)
filter(as.vector(x) + as.vector(e), ar, method="recursive", init=Y0)
Y0
ar
length(AR)
length(init)
length(ar)
filter(as.vector(x) + as.vector(e), ar, method="recursive", init=vector(Y0))
filter
filter(as.vector(x) + as.vector(e), ar, method="recursive", init=vector(Y0))
filter(as.vector(x) + as.vector(e), ar, method="recursive", init=as.vector(Y0))
yt
yf <- filter(as.vector(x) + as.vector(e), ar, method="recursive", init=as.vector(Y0))
yf
cbind(yt, yf)
yf-yt
yt
as.vector(yt)
as.vector(yt) - yf
as.vector(yt) - as.vector(yf)
x
yf
yf-yt
dim(ar)
ar
Y0
dim(Y0
)
yf
yf
as.matrix(yf)
yt
X <- cbind(x, x + t(e))
YY0 <- cbind(t(Y0), t(Y0))
YY0
filter(X, ar, method="recursive", init=YY0)
0
m$residuals
nrow(df)
m$keepCX
m$response - m$coefficients %*% m$X
m$coefficients
V
nac
e
m$coefficients <- m$coefficients + e
m$coefficients
?reshape
0
length(pib)
piy$keepCX
piy$X
m$X
m
names(m)
m$cX
summary(m)
m$X
0
simmodel("Washington")
simmodel("Washington")
simmodel("Washington", samplecoefs = TRUE)
foo <- simmodel("Washington", samplecoefs = TRUE)
foo$y
foo$y - foo$yf
0
foo <- simmodel("Washington", samplecoefs = TRUE)
foo
0
nopstatesim("Washington", nsim=20, simmodel, maskmodel, sdf)
nopstatesim("Washington", nsim=20, simmodel, maskmodel, sdf)
ls()
cfyu
cfyi
dim(cfyi)
dim(yi)
date
ls()
est
c
ls()
cfy
cfyi
ls()
dy
dcfy
cumsum(exp(cfyi))/cumsum(exp(yi))-1
0
0
0
0
nopstatesim("Washington", nsim=20, simmodel, maskmodel, sdf)
rowMeans(exp(yi))
rowMeans(exp(cfyi))
cumsum(exp(cfyi))
?cumsum
0
?sapply
nopstatesim("Washington", nsim=3, simmodel, maskmodel, sdf)
ls()
apply(exp(yi), 1, cumsum)
apply(exp(yi), 2, cumsum)
apply(exp(cfyi), 2, cumsum)
131/160 - 1
apply(exp(cfyi), 2, cumsum)/
                  apply(exp(yi), 2, cumsum)- 1
c
nopstatesim("Washington", nsim=3, simmodel, maskmodel, sdf)
nopstatesim("Washington", nsim=3, simmodel, maskmodel, sdf)
foo <- nopstatesim("Washington", nsim=3, simmodel, maskmodel, sdf)
names(foo)
names(foo$edf)
foo$mcum - foo$mclcum
foo$edf$mcum - foo$edf$mclcum
foo$edf$mcum 
foo$edf$mcum - foo$edf$clcum
foo$edf$mcum 
names(foo$edf)
dim(matrix(0, nrow=2, ncol=3))
source("counterfactuals.R")
source("counterfactuals.R")
source("counterfactuals.R")
maskall
200*length(unique(sdf$date))
200*length(unique(sdf$date))*2
exp(-1)
0
names(figs)
print(figs$r)
print(figs$cr)
dev.new()
print(fig$r)
print(figs$r)
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd")
render_site("cf-pindex.Rmd")
0
q()
n
